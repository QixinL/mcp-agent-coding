from mcp_agent.agents.agent import Agent
from pydantic import BaseModel, Field
from langchain.output_parsers import PydanticOutputParser

#Planning agent
class PlanStep(BaseModel):
    agent: str = Field(..., description="Which agent performs this step")
    instruction: str = Field(..., description="The instruction for the agent to perform this step")

class Plan(BaseModel):
    steps: list[PlanStep]

#Finding agent
class FindingSchema(BaseModel):
    status: str = Field(..., description="The status of the finding step, e.g., 'pass' or 'error'")
    path: str = Field(..., description="The path to the file found by the finder agent relative to the current working directory")
    summary: str = Field(..., description="A short summary of what was accomplished and the key results of this step")
    #TODO obtain header

#Coding agent
class CodingSchema(BaseModel):
    status: str = Field(..., description="The status of the code step, e.g., 'pass' or 'error'")
    code: str = Field(..., description="The code generated by the coder agent")
    path: str = Field(..., description="The path to the file where the code is saved relative to the current working directory")
    summary: str = Field(..., description="A short summary of what was accomplished and the key results of this step")

#Execution agent
class ExecutionSchema(BaseModel):
    status: str = Field(..., description="The status of the execution step, e.g., 'pass' or 'error'")
    output: str = Field(..., description="The output of the executed code or the error message if the execution failed")
    summary: str = Field(..., description="A short summary of what was accomplished and the key results of this step")



class Orchestrator():
    def __init__(self, augumented_llm, available_agents):
        # The augmented_llm should be an instance of OpenAIAugmentedLLM or GoogleAugmentedLLM
        self.augmented_llm = augumented_llm
        # The available_agents should be a dictionary or list of Agent instances
        self.available_agents = {agent.name: agent for agent in available_agents}
    
        self.parsers = {
            "planner": PydanticOutputParser(pydantic_object=Plan),
            "finder": PydanticOutputParser(pydantic_object=FindingSchema),
            "coder": PydanticOutputParser(pydantic_object=CodingSchema),
            "executor": PydanticOutputParser(pydantic_object=ExecutionSchema),
        }
        self.file_path = ""
        self.csv_path = ""
    
    #TODO put into utils
    def create_python_file(self, code, file_name):
        """
        Create a Python file with the given code and file name.
        The file will be created in the current working directory.
        """
        with open(file_name, "w") as f:
            f.write(code)
        print(f"Python file '{file_name}' created successfully.")
        return file_name
    
    async def llm_factory(self, agent):
        return await agent.attach_llm(self.augmented_llm)


    #generate plan
    async def generate_plan(self, user_query):
        # This method would contain the logic to generate a plan using the available agents
        planning_agent=Agent(
            name="planner",
            instruction="""
            You are an expert planner. Given an objective task and a list of MCP servers (which are collections of tools)
            or Agents (which are collections of servers), your job is to break down the objective into a series of steps,
            which can be performed by LLMs with access to the servers or agents.
            """,
        )
        planning_llm = await self.llm_factory(planning_agent)
        parser = self.parsers["planner"]
        format_instructions = parser.get_format_instructions()

        prompt = f"""
        You are an expert planner. Break down the task into JSON steps. Provide sufficient context for each instruction.
        {format_instructions}

        Task: {user_query}
        Available agents: {[agent for agent in self.available_agents.values()]
        }
        """
        
        raw = await planning_llm.generate_str(prompt)

        plan: Plan = parser.parse(raw)
        return plan.model_dump()

    async def orchestrate_plan(self, user_query, plan):
        #create an orchestrator agent that will review the output of the agents and update the instruction if needed
        orchestrator_agent = Agent(
            name="orchestrator",
            instruction="""
            You are an orchestrator agent. Your job is to oversee the execution of the plan.
            Review the output of each agent and update the instructions for the next agent if needed.
            """,
        )

        result_json = None

        for step in plan["steps"]:
            agent_name = step["agent"]
            instruction = step["instruction"]

            #invoke the orchestrator agent to review the output and update the instruction
            if result_json is not None:
                orchestrator_llm = await self.llm_factory(orchestrator_agent)

                prompt = f"""
                Current task: {user_query}
                Previous agent output: {result_json}
                Current step instruction: {instruction}
                Current agent: {agent_name}
                Your job is to review the previous agent's output and update the instruction for the current agent with the necessary context.
                Ensure that:
                - As few changes as possible are made to the instruction.
                - The current agent has all the necessary context to perform its task.
                - You provide the exact path obtained from the previous agent's output if it is relevant to the current agent.
                """
            
                #update the instruction with the context from the previous agent's output
                instruction = await orchestrator_llm.generate_str(prompt)
            print(f"\nExecuting step for agent: {agent_name} with instruction: {instruction}")


            if agent_name not in self.available_agents:
                raise ValueError(f"Agent {agent_name} is not available.")

            agent = self.available_agents[agent_name]
            agent_llm = await self.llm_factory(agent)
            parser = self.parsers[agent_name]

            format_instructions = parser.get_format_instructions()
            prompt = f"""
            Produce one JSON object matching this schema:
            {format_instructions}

            Task: {instruction}
            """
            
            raw = await agent_llm.generate_str(prompt)
            print(f"\n Raw response from {agent_name} agent: {raw}")
            result = parser.parse(raw)

            result_json = result.model_dump()
            
            if agent_name == "finder":
                self.file_path = result_json.get("path", "")
            elif agent_name == "coder":
                self.csv_path = result_json.get("path", "")
                self.create_python_file(result_json.get("code", ""), self.csv_path)



    async def generate_str(self, user_query):
        print(f"User query: {user_query}")
        print(f"Available agents: {self.available_agents.keys()}")
        print("Starting orchestration...\n")
        #test run generate_plan
        plan = await self.generate_plan(user_query)
        print(f"Generated plan: {plan}")
        #test run orchestrate_plan
        await self.orchestrate_plan(user_query, plan)
        print("Orchestration complete.")
        



        
